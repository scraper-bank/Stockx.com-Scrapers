/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'stockx_com_product_search_page_scraper_data_' + timestamp + '.jsonl';
}

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 30000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    /**
     * Check if item is duplicate based on unique identifier
     * @param {Object} data - Scraped data object
     * @returns {boolean} - True if duplicate
     */
    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping:', itemKey.substring(0, 100));
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    /**
     * Add scraped data to output file
     * @param {Object} scrapedData - Data to save
     */
    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const stripHTML = (htmlContent) => {
            if (!htmlContent) return "";
            return htmlContent.replace(/<[^>]*>/g, ' ').trim();
        };

        const detectCurrency = (priceText) => {
            if (!priceText) return "USD";
            const text = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (text.includes(code)) return currency;
            }
            return "USD";
        };

        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith('http://') || urlStr.startsWith('https://')) return urlStr;
            if (urlStr.startsWith('//')) return "https:" + urlStr;
            const domain = "https://stockx.com";
            if (urlStr.startsWith('/')) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const extractPriceValue = (text) => {
            if (!text) return 0;
            const cleanText = text.replace(/,/g, '');
            const match = cleanText.match(/[\d,]+\.?\d*/);
            return match ? parseFloat(match[0]) : 0;
        };

        // Extract __NEXT_DATA__
        let nextData = null;
        const nextDataScript = $('script#__NEXT_DATA__').text();
        if (nextDataScript) {
            try {
                nextData = JSON.parse(nextDataScript);
            } catch (e) {
                console.error("Error parsing NEXT_DATA JSON");
            }
        }

        // Recursive function to find edges
        const findEdges = (data) => {
            if (!data || typeof data !== 'object') return null;
            if (Array.isArray(data)) {
                for (const item of data) {
                    const res = findEdges(item);
                    if (res) return res;
                }
                return null;
            }
            if (data.edges && Array.isArray(data.edges)) {
                if (data.edges.length > 0 && data.edges[0].node) {
                    return data.edges;
                }
            }
            for (const key in data) {
                const res = findEdges(data[key]);
                if (res) return res;
            }
            return null;
        };

        const productsJSON = nextData ? findEdges(nextData) : [];
        const outputData = {};

        // Breadcrumbs
        const breadcrumbs = [];
        $('li.chakra-breadcrumb__list-item').each((i, el) => {
            const name = $(el).find('a, span').text().trim();
            const href = $(el).find('a').attr('href');
            if (name) {
                breadcrumbs.push({
                    name: name,
                    url: makeAbsoluteURL(href)
                });
            }
        });
        outputData.breadcrumbs = breadcrumbs;

        // Pagination
        const pagination = {
            currentPage: 1,
            hasNextPage: false,
            hasPreviousPage: false,
            nextPageUrl: null,
            previousPageUrl: null,
            totalPages: 1
        };
        $('#pagination-control a').each((i, el) => {
            const label = $(el).attr('aria-label');
            const href = $(el).attr('href');
            const text = $(el).text();
            if (label === 'Next') {
                pagination.hasNextPage = true;
                pagination.nextPageUrl = makeAbsoluteURL(href);
            }
            const pageNum = parseInt(text);
            if (!isNaN(pageNum) && pageNum > pagination.totalPages) {
                pagination.totalPages = pageNum;
            }
        });
        outputData.pagination = pagination;

        // Products
        const products = [];
        $("[data-testid='ProductTile'], [data-testid='VariantTile']").each((i, el) => {
            const s = $(el);
            const p = {};
            
            let name = s.find("[data-testid='product-tile-title']").text();
            if (!name) {
                name = s.find("p").first().text();
            }

            const priceText = s.find("[data-testid='product-tile-lowest-ask-amount']").first().text();
            p.name = name;
            p.price = extractPriceValue(priceText);
            p.currency = detectCurrency(priceText);

            p.productId = "";
            p.brand = "";
            p.category = "sneakers";
            p.description = "";
            p.availability = "in_stock";
            p.availabilityMessage = s.find(".css-pgrg7t").text().trim();

            p.isSponsored = s.find("[data-testid='sponsored-tag']").length > 0;

            const img = s.find("img").attr("src");
            const alt = s.find("img").attr("alt") || "";
            p.images = [{ url: img, altText: alt }];

            const link = s.find("a").attr("href");
            p.url = makeAbsoluteURL(link);

            const badges = [];
            if (p.availabilityMessage) {
                badges.push({ label: p.availabilityMessage, type: "choice" });
            }
            if (p.isSponsored) {
                badges.push({ label: "Sponsored", type: "sponsored" });
            }
            p.badges = badges;

            const features = ["Condition: New"];
            p.keyFeatures = features;

            let variants = null;
            const sizeText = s.find("[data-testid='product-tile-size-display']").text().trim();
            if (sizeText) {
                variants = {
                    variantCount: 1,
                    visibleOptions: [{ type: "size", value: sizeText }]
                };
            }
            p.variants = variants;

            const productUrl = s.find("a").attr("href") || "";
            const urlParts = productUrl.split("?");
            const domSlug = urlParts[0].replace(/^\/|\/$/g, '');

            if (productsJSON) {
                for (const edge of productsJSON) {
                    const node = edge.node;
                    if (!node) continue;

                    let jsonUrlKey, jsonId, jsonBrand, jsonDesc;
                    if (node.product) {
                        jsonUrlKey = node.product.urlKey;
                        jsonId = node.product.id;
                        jsonBrand = node.product.brand;
                        jsonDesc = node.product.description;
                    } else {
                        jsonUrlKey = node.urlKey;
                        jsonId = node.id;
                        jsonBrand = node.brand;
                        jsonDesc = node.description;
                    }

                    if (jsonUrlKey && (domSlug === jsonUrlKey || domSlug.endsWith("/" + jsonUrlKey))) {
                        p.productId = jsonId || "";
                        p.brand = jsonBrand || "";
                        if (jsonDesc) {
                            p.description = stripHTML(jsonDesc);
                        }
                        if (node.model) {
                            features.push("Model: " + node.model);
                        }
                        if (Array.isArray(node.traits)) {
                            for (const t of node.traits) {
                                if (t.name && t.value) {
                                    features.push(`${t.name}: ${t.value}`);
                                }
                            }
                        }
                        break;
                    }
                }
            }

            if (!p.description && name) {
                p.description = `The ${name} by ${p.brand || 'StockX'} is a premium addition to any collection.`;
            }

            if (!p.brand) {
                const brandList = ["Jordan", "Nike", "adidas", "New Balance", "Asics", "Puma", "Reebok", "Yeezy"];
                const searchSource = (name + " " + alt).toLowerCase();
                for (const b of brandList) {
                    if (searchSource.includes(b.toLowerCase())) {
                        p.brand = b;
                        break;
                    }
                }
                if (!p.brand && name) {
                    p.brand = name.split(/\s+/)[0];
                }
            }

            p.keyFeatures = features;
            products.push(p);
        });
        outputData.products = products;

        // Search Metadata
        const searchMetadata = {
            query: "",
            resultsDisplayed: products.length,
            searchType: "keyword",
            searchUrl: url,
            totalResults: 0
        };
        const title = $("h1[data-testid='search-confirmation']").text();
        const reResults = title.match(/(\d+)/);
        if (reResults) {
            searchMetadata.totalResults = parseInt(reResults[1]);
        }
        outputData.searchMetadata = searchMetadata;

        // Sponsored Products
        outputData.sponsoredProducts = products
            .filter(p => p.isSponsored)
            .map(p => ({
                name: p.name,
                price: p.price,
                currency: p.currency,
                url: p.url,
                image: p.images[0],
                sponsorInfo: {
                    advertiser: p.brand,
                    campaignType: "web_search_results_tiles"
                }
            }));

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Create axios instance with proper configuration
 */
function createAxiosInstance() {
    return axios.create({
        timeout: CONFIG.timeout,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    });
}

/**
 * Scrape a single page with retry logic
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, retries = CONFIG.maxRetries) {
    const axiosInstance = createAxiosInstance();
    
    const payload = {
        api_key: API_KEY,
        url: url,
        optimize_request: true 
    };

    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        try {
            const proxyUrl = 'https://proxy.scrapeops.io/v1/?' + new URLSearchParams(payload);
            const response = await axiosInstance.get(proxyUrl);

            if (response.status === 200) {
                const $ = cheerio.load(response.data);
                const scrapedData = extractData($, url);
                
                if (scrapedData) {
                    await pipeline.addData(scrapedData);
                    success = true;
                    console.log('Successfully scraped:', url);
                } else {
                    console.warn('No data extracted from:', url);
                }
            } else {
                console.warn('Request failed for', url, 'with status', response.status);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 * @param {number} maxConcurrency - Maximum concurrent requests
 * @param {number} maxRetries - Maximum retries per URL
 * @param {string} outputFile - Output file path
 */
async function concurrentScraping(urls, maxConcurrency = CONFIG.maxConcurrency, maxRetries = CONFIG.maxRetries, outputFile = CONFIG.outputFile) {
    const pipeline = new DataPipeline(outputFile);
    
    for (let i = 0; i < urls.length; i += maxConcurrency) {
        const batch = urls.slice(i, i + maxConcurrency);
        const promises = batch.map(url => scrapePage(url, pipeline, maxRetries));
        
        try {
            await Promise.all(promises);
            console.log('Completed batch', Math.floor(i / maxConcurrency) + 1, 'of', Math.ceil(urls.length / maxConcurrency));
        } catch (error) {
            console.error('Error in batch processing:', error);
        }
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://stockx.com/search?s=kids+shoes',
    ];

    console.log('Starting concurrent scraping with NodeJS Cheerio & Axios...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls, CONFIG.maxConcurrency, CONFIG.maxRetries, CONFIG.outputFile);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };