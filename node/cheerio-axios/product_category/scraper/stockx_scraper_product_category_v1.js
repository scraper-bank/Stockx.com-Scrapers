/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'stockx_com_product_category_page_scraper_data_' + timestamp + '.jsonl';
}

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 30000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    /**
     * Check if item is duplicate based on unique identifier
     * @param {Object} data - Scraped data object
     * @returns {boolean} - True if duplicate
     */
    isDuplicate(data) {
        const itemKey = data.productId || JSON.stringify(data.url);
        if (this.itemsSeen.has(itemKey)) {
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    /**
     * Add scraped data to output file
     * @param {Object} scrapedData - Data to save
     */
    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Helper to strip HTML tags from a string
 * @param {string} s 
 * @returns {string}
 */
function stripHTML(s) {
    if (!s) return "";
    return s.replace(/<[^>]*>/g, ' ').trim();
}

/**
 * Detects currency from price string
 * @param {string} priceText 
 * @returns {string}
 */
function detectCurrency(priceText) {
    if (!priceText) return "USD";
    const text = priceText.toUpperCase();
    const currencyMap = {
        "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
        "EUR": "EUR", "€": "EUR",
        "GBP": "GBP", "£": "GBP", "GB£": "GBP",
        "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
        "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
        "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
        "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
        "CHF": "CHF", "FR.": "CHF",
        "SEK": "SEK", "KR": "SEK",
        "NZD": "NZD", "NZ$": "NZD",
    };
    for (const [code, currency] of Object.entries(currencyMap)) {
        if (text.includes(code)) return currency;
    }
    return "USD";
}

/**
 * Resolves relative URLs to absolute stockx URLs
 * @param {string} urlStr 
 * @returns {string}
 */
function makeAbsoluteURL(urlStr) {
    if (!urlStr) return "";
    if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
    if (urlStr.startsWith("//")) return "https:" + urlStr;
    const domain = "https://stockx.com";
    if (urlStr.startsWith("/")) return domain + urlStr;
    return domain + "/" + urlStr;
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const outputData = {};
        
        // Extract Next Data
        let nextData = null;
        const nextDataScript = $("script#__NEXT_DATA__").first().text();
        if (nextDataScript) {
            try {
                nextData = JSON.parse(nextDataScript);
            } catch (e) {
                console.error("Failed to parse __NEXT_DATA__");
            }
        }

        // Applied Filters
        const appliedFilters = [];
        const filterNode = $("p.chakra-text.css-m41fx8").first();
        if (filterNode.length > 0) {
            appliedFilters.push({
                filterName: "CATEGORY",
                filterValue: filterNode.text().trim()
            });
        }
        outputData.appliedFilters = appliedFilters;

        // Banner Image
        outputData.bannerImage = $("meta[property='og:image']").attr("content") || "";

        // Breadcrumbs
        const breadcrumbs = [];
        $("script[type='application/ld+json'][data-testid='breadcrumb-schema']").each((i, el) => {
            try {
                const ld = JSON.parse($(el).text());
                if (ld.itemListElement && Array.isArray(ld.itemListElement)) {
                    ld.itemListElement.forEach(item => {
                        if (item.item) {
                            breadcrumbs.push({
                                name: item.item.name,
                                url: item.item["@id"]
                            });
                        }
                    });
                }
            } catch (e) {}
        });
        outputData.breadcrumbs = breadcrumbs;

        // Category Info
        let catId = "";
        try {
            catId = nextData?.query?.level1Category || "";
        } catch (e) {}
        outputData.categoryId = catId;
        outputData.categoryName = $("h1.chakra-heading").first().text().trim();
        outputData.categoryUrl = makeAbsoluteURL("/category/" + catId);

        // Description
        const descParts = [];
        $(".css-0 p.chakra-text").each((i, el) => {
            descParts.push($(el).text().trim());
        });
        outputData.description = descParts.join("\n");

        // Pagination
        const pagination = {
            currentPage: 1,
            nextPageUrl: null,
            prevPageUrl: null,
            resultsPerPage: 40,
            totalPages: 1,
            totalResults: 0,
        };
        
        if (nextDataScript) {
            const pageCountMatch = nextDataScript.match(/"pageCount":(\d+)/);
            const totalMatch = nextDataScript.match(/"total":(\d+)/);
            if (pageCountMatch) pagination.totalPages = parseInt(pageCountMatch[1]);
            if (totalMatch) pagination.totalResults = parseInt(totalMatch[1]);
        }
        
        const nextHref = $("a[aria-label='Next']").attr("href");
        if (nextHref) pagination.nextPageUrl = makeAbsoluteURL(nextHref);
        outputData.pagination = pagination;

        // Product ID Mapping
        const productMap = {}; // slug -> id
        try {
            const queries = nextData?.props?.pageProps?.states?.query?.value?.queries || [];
            queries.forEach(q => {
                const edges = q.state?.data?.browse?.results?.edges || [];
                edges.forEach(edge => {
                    const node = edge.node;
                    if (node?.id && node?.urlKey) {
                        productMap[node.urlKey] = node.id;
                    }
                });
            });
        } catch (e) {}

        const globalProductMap = {};
        if (nextDataScript) {
            // Forward Pattern: "id":"UUID" ... "urlKey":"SLUG"
            const reForward = /"id"\s*:\s*"([a-f0-9\-]{36})"\s*,[^}]*?"urlKey"\s*:\s*"([^"\s]+)"/gs;
            let match;
            while ((match = reForward.exec(nextDataScript)) !== null) {
                globalProductMap[match[2]] = match[1];
            }
            // Backward Pattern: "urlKey":"SLUG" ... "id":"UUID"
            const reBackward = /"urlKey"\s*:\s*"([^"\s]+)"\s*,[^}]*?"id"\s*:\s*"([a-f0-9\-]{36})"/gs;
            while ((match = reBackward.exec(nextDataScript)) !== null) {
                globalProductMap[match[1]] = match[2];
            }
        }

        // Extracted Products
        const products = [];
        $("[data-testid='ProductTile'], [data-testid='VariantTile']").each((i, el) => {
            const s = $(el);
            const p = {
                availability: "in_stock",
                isPrime: false,
                rating: null,
                reviewCount: null,
                preDiscountPrice: null
            };

            let name = s.find("[data-testid='product-tile-title']").first().text().trim();
            if (!name) name = s.find("img").first().attr("alt") || "";
            p.name = name;
            p.brand = name.split(" ")[0] || "";

            const priceText = s.find("[data-testid='product-tile-lowest-ask-amount']").first().text().trim();
            p.currency = detectCurrency(priceText);
            
            const priceClean = priceText.replace(/,/g, "");
            const priceMatch = priceClean.match(/[\d.]+/);
            p.price = priceMatch ? parseFloat(priceMatch[0]) : 0;

            p.image = s.find("img").first().attr("src") || "";
            
            const href = s.find("a").first().attr("href") || "";
            p.url = makeAbsoluteURL(href);

            // Product ID Strategy
            let productId = "";
            const cleanHref = href.split("?")[0].replace(/^\/+|\/+$/g, "");
            const urlParts = cleanHref.split("/");
            const slug = urlParts[urlParts.length - 1] || "";

            if (slug) {
                productId = productMap[slug] || globalProductMap[slug] || "";
                
                if (!productId && nextDataScript) {
                    const escapedSlug = slug.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // Forward proximity
                    const reF = new RegExp(`"${escapedSlug}".{1,500}?"([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})"`, "s");
                    const mF = nextDataScript.match(reF);
                    if (mF) productId = mF[1];
                    
                    if (!productId) {
                        const reB = new RegExp(`"([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})".{1,500}?"${escapedSlug}"`, "s");
                        const mB = nextDataScript.match(reB);
                        if (mB) productId = mB[1];
                    }
                }

                if (!productId) productId = s.attr("data-product-id") || "";
            }
            p.productId = productId;
            p.isSponsored = s.find("[data-testid='sponsored-tag']").length > 0 || s.attr("data-sponsored-listing") === "true";

            products.push(p);
        });
        outputData.products = products;

        // Subcategories
        const subcats = [];
        $(".filter.css-qlswoo a").each((i, el) => {
            subcats.push({
                name: $(el).text().trim(),
                url: makeAbsoluteURL($(el).attr("href") || ""),
                productCount: null
            });
        });
        outputData.subcategories = subcats;

        // Default empty fields for consistency
        outputData.aggregateRating = { bestRating: 5, ratingValue: 0, reviewCount: 0, worstRating: 1 };
        outputData.features = [];
        outputData.images = [];
        outputData.reviews = [];
        outputData.seller = { name: "StockX", rating: null, url: "https://stockx.com" };
        outputData.serialNumbers = [];
        outputData.specifications = [];
        outputData.videos = [];
        outputData.timestamp = new Date().toISOString();

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Create axios instance with proper configuration
 */
function createAxiosInstance() {
    return axios.create({
        timeout: CONFIG.timeout,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    });
}

/**
 * Scrape a single page with retry logic
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, retries = CONFIG.maxRetries) {
    const axiosInstance = createAxiosInstance();
    
    const payload = {
        api_key: API_KEY,
        url: url,
        optimize_request: true 
    };

    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        try {
            const proxyUrl = 'https://proxy.scrapeops.io/v1/?' + new URLSearchParams(payload);
            const response = await axiosInstance.get(proxyUrl);

            if (response.status === 200) {
                const $ = cheerio.load(response.data);
                
                const scrapedData = extractData($, url);
                
                if (scrapedData) {
                    await pipeline.addData(scrapedData);
                    success = true;
                    console.log('Successfully scraped:', url);
                } else {
                    console.warn('No data extracted from:', url);
                }
            } else {
                console.warn('Request failed for', url, 'with status', response.status);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 * @param {number} maxConcurrency - Maximum concurrent requests
 * @param {number} maxRetries - Maximum retries per URL
 * @param {string} outputFile - Output file path
 */
async function concurrentScraping(urls, maxConcurrency = CONFIG.maxConcurrency, maxRetries = CONFIG.maxRetries, outputFile = CONFIG.outputFile) {
    const pipeline = new DataPipeline(outputFile);
    
    for (let i = 0; i < urls.length; i += maxConcurrency) {
        const batch = urls.slice(i, i + maxConcurrency);
        const promises = batch.map(url => scrapePage(url, pipeline, maxRetries));
        
        try {
            await Promise.all(promises);
            console.log('Completed batch', Math.floor(i / maxConcurrency) + 1, 'of', Math.ceil(urls.length / maxConcurrency));
        } catch (error) {
            console.error('Error in batch processing:', error);
        }
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://stockx.com/category/electronics',
    ];

    console.log('Starting concurrent scraping with NodeJS Cheerio & Axios...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls, CONFIG.maxConcurrency, CONFIG.maxRetries, CONFIG.outputFile);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };