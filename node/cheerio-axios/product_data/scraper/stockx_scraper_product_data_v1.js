/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'stockx_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 30000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    /**
     * Check if item is duplicate based on unique identifier
     * @param {Object} data - Scraped data object
     * @returns {boolean} - True if duplicate
     */
    isDuplicate(data) {
        const itemKey = data.productId || JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping:', String(itemKey).substring(0, 100));
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    /**
     * Add scraped data to output file
     * @param {Object} scrapedData - Data to save
     */
    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Helper to strip HTML tags from string
 * @param {string} html 
 * @returns {string}
 */
function stripHTML(html) {
    if (!html) return '';
    return html.replace(/<[^>]*>/g, ' ').trim();
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://stockx.com";
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            const text = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (text.includes(code)) return currency;
            }
            return "USD";
        };

        let jsonLD = null;
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const content = JSON.parse($(el).text());
                const items = Array.isArray(content) ? content : [content];
                for (const item of items) {
                    if (item['@type'] === 'Product') {
                        jsonLD = item;
                        break;
                    }
                }
            } catch (e) {}
        });

        let nextData = null;
        try {
            const nextText = $("script#__NEXT_DATA__").text();
            if (nextText) nextData = JSON.parse(nextText);
        } catch (e) {}

        const outputData = {};
        outputData["aggregateRating"] = null;

        // Availability
        let availability = "in_stock";
        if (jsonLD?.offers?.availability && jsonLD.offers.availability.includes("InStock")) {
            availability = "in_stock";
        }
        outputData["availability"] = availability;

        // Brand
        let brand = jsonLD?.brand?.name || "";
        if (!brand) {
            $("[data-component='product-trait']").each((i, el) => {
                const text = $(el).text();
                if (text.includes("Brand")) {
                    brand = $(el).find("p").text().trim();
                }
            });
        }
        outputData["brand"] = brand;

        // Category
        outputData["category"] = jsonLD?.category || "";

        // Currency
        let currency = jsonLD?.offers?.priceCurrency || "USD";
        outputData["currency"] = currency;

        // Description
        let description = jsonLD?.description || $("[data-testid='product-description'] p").text() || "";
        outputData["description"] = description;
        outputData["features"] = [];

        // Product Name
        let productName = jsonLD?.name || $("[data-component='primary-product-title']").first().text() || "";
        productName = productName.trim();

        // Images
        const images = [];
        const seenImages = new Set();

        const cleanStockXUrl = (u) => {
            if (!u || !u.includes("images.stockx.com")) return u;
            const base = u.split("?")[0];
            return base + "?fit=fill&bg=FFFFFF&w=1200&h=857&q=100";
        };

        const isValidProductImage = (u) => {
            if (!u) return false;
            const lower = u.toLowerCase();
            const blacklist = ["merchandising", "surfacing_reviews", "images-cs.stockx.com", "assets/blt", "payment-methods", "sellingfast"];
            return !blacklist.some(term => lower.includes(term));
        };

        // Extraction Strategy: NextData
        if (nextData) {
            const findGallery = (data) => {
                if (typeof data !== 'object' || data === null) return null;
                if (data.product?.media?.gallery) return data.product.media.gallery;
                
                if (Array.isArray(data)) {
                    for (const item of data) {
                        const res = findGallery(item);
                        if (res) return res;
                    }
                } else {
                    for (const [k, v] of Object.entries(data)) {
                        if (k === "merchandising" || k === "menuCollection") continue;
                        const res = findGallery(v);
                        if (res) return res;
                    }
                }
                return null;
            };

            const gallery = findGallery(nextData);
            if (Array.isArray(gallery)) {
                gallery.forEach((imgURL, idx) => {
                    if (typeof imgURL === 'string' && imgURL && isValidProductImage(imgURL)) {
                        const finalURL = cleanStockXUrl(imgURL);
                        if (!seenImages.has(finalURL)) {
                            seenImages.add(finalURL);
                            const alt = idx > 0 ? `${productName} back view` : productName;
                            images.push({
                                url: makeAbsoluteURL(finalURL),
                                alt_text: alt.trim()
                            });
                        }
                    }
                });
            }
        }

        // Fallback 1: JSON-LD
        if (images.length === 0 && jsonLD?.image) {
            const img = jsonLD.image;
            if (isValidProductImage(img)) {
                const finalURL = cleanStockXUrl(img);
                images.push({
                    url: makeAbsoluteURL(finalURL),
                    alt_text: productName
                });
                seenImages.add(finalURL);
            }
        }

        // Fallback 2: DOM
        if (images.length === 0) {
            $("img[data-component='StandardImage'], [data-testid='MultiImage'] img").each((i, el) => {
                const src = $(el).attr("src");
                if (src && isValidProductImage(src)) {
                    const finalURL = cleanStockXUrl(src);
                    if (!seenImages.has(finalURL)) {
                        seenImages.add(finalURL);
                        let alt = $(el).attr("alt") || productName;
                        if (alt === "nextProductImage") alt = productName;
                        images.push({
                            url: makeAbsoluteURL(finalURL),
                            alt_text: alt.trim()
                        });
                    }
                }
            });
        }
        outputData["images"] = images;

        // Name
        outputData["name"] = productName;
        outputData["preDiscountPrice"] = null;

        // Price
        let price = 0;
        const priceText = $("[data-testid='trade-box-buy-amount']").first().text();
        if (!priceText && jsonLD?.offers?.lowPrice) {
            price = parseFloat(jsonLD.offers.lowPrice);
        } else if (priceText) {
            const match = priceText.match(/[\d,.]+/);
            if (match) {
                const clean = match[0].replace(/,/g, '');
                price = parseFloat(clean);
                if (currency === "USD") {
                    currency = detectCurrency(priceText);
                }
            }
        }
        outputData["price"] = price;
        outputData["currency"] = currency;

        // Product ID
        const productId = jsonLD?.sku || "";
        outputData["productId"] = productId;
        outputData["reviews"] = [];
        outputData["seller"] = {
            "name": "StockX",
            "rating": null,
            "url": "https://stockx.com"
        };

        // Serial Numbers
        const serialNumbers = [];
        if (productId) serialNumbers.push({ type: "SKU", value: productId });
        if (jsonLD?.gtin) serialNumbers.push({ type: "GTIN", value: jsonLD.gtin });
        
        let style = "";
        $("[data-component='product-trait']").each((i, el) => {
            if ($(el).text().includes("Style")) {
                style = $(el).find("p").text().trim();
            }
        });
        if (style) serialNumbers.push({ type: "Other", value: style });
        outputData["serialNumbers"] = serialNumbers;

        // Specifications
        const specs = [];
        $("[data-component='product-trait']").each((i, el) => {
            const k = $(el).find("span").first().text().trim();
            const v = $(el).find("p").first().text().trim();
            if (k && v) specs.push({ key: k, value: v });
        });
        if (jsonLD?.model) specs.push({ key: "Model", value: jsonLD.model });
        outputData["specifications"] = specs;

        // URL
        let canonicalUrl = jsonLD?.url || $("link[rel='canonical']").attr("href") || url;
        outputData["url"] = makeAbsoluteURL(canonicalUrl);
        outputData["videos"] = null;
        outputData["timestamp"] = new Date().toISOString();

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Create axios instance with proper configuration
 */
function createAxiosInstance() {
    return axios.create({
        timeout: CONFIG.timeout,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    });
}

/**
 * Scrape a single page with retry logic
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, retries = CONFIG.maxRetries) {
    const axiosInstance = createAxiosInstance();
    
    const payload = {
        api_key: API_KEY,
        url: url,
        optimize_request: true 
    };

    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        try {
            const proxyUrl = 'https://proxy.scrapeops.io/v1/?' + new URLSearchParams(payload);
            const response = await axiosInstance.get(proxyUrl);

            if (response.status === 200) {
                const $ = cheerio.load(response.data);
                const scrapedData = extractData($, url);
                
                if (scrapedData) {
                    await pipeline.addData(scrapedData);
                    success = true;
                    console.log('Successfully scraped:', url);
                } else {
                    console.warn('No data extracted from:', url);
                }
            } else {
                console.warn('Request failed for', url, 'with status', response.status);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 * @param {number} maxConcurrency - Maximum concurrent requests
 * @param {number} maxRetries - Maximum retries per URL
 * @param {string} outputFile - Output file path
 */
async function concurrentScraping(urls, maxConcurrency = CONFIG.maxConcurrency, maxRetries = CONFIG.maxRetries, outputFile = CONFIG.outputFile) {
    const pipeline = new DataPipeline(outputFile);
    
    for (let i = 0; i < urls.length; i += maxConcurrency) {
        const batch = urls.slice(i, i + maxConcurrency);
        const promises = batch.map(url => scrapePage(url, pipeline, maxRetries));
        
        try {
            await Promise.all(promises);
            console.log('Completed batch', Math.floor(i / maxConcurrency) + 1, 'of', Math.ceil(urls.length / maxConcurrency));
        } catch (error) {
            console.error('Error in batch processing:', error);
        }
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://stockx.com/adidas-ctt-chinese-track-top-31-gender-neutral-jacket-asia-sizing-dark-grey',
    ];

    console.log('Starting concurrent scraping with NodeJS Cheerio & Axios...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls, CONFIG.maxConcurrency, CONFIG.maxRetries, CONFIG.outputFile);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };