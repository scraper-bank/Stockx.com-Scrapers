/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const { chromium } = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
chromium.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'stockx_com_product_search_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_CONFIG = {
    server: 'http://residential-proxy.scrapeops.io:8181',
    username: 'scrapeops',
    password: API_KEY
};

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://stockx.com";
            return urlStr.startsWith("/") ? domain + urlStr : `${domain}/${urlStr}`;
        };

        const detectCurrency = (priceText) => {
            const text = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (text.includes(code)) return currency;
            }
            return "USD";
        };

        const extractNumericPrice = (priceText) => {
            const match = priceText.replace(/,/g, "").match(/([\d,]+\.?\d*)/);
            return match ? parseFloat(match[1]) : 0;
        };

        let nextData = null;
        const nextDataScript = $("script#__NEXT_DATA__").text();
        if (nextDataScript) {
            try {
                nextData = JSON.parse(nextDataScript);
            } catch (e) {
                console.error("Error parsing NEXT_DATA JSON");
            }
        }

        const slugToId = {};
        const slugToDescription = {};

        const findNodes = (val) => {
            if (!val || typeof val !== 'object') return;
            if (Array.isArray(val)) {
                val.forEach(findNodes);
                return;
            }
            const { id, urlKey, description } = val;
            if (urlKey && typeof urlKey === 'string') {
                if (id && typeof id === 'string' && id.length > 20) {
                    slugToId[urlKey] = id;
                }
                if (description && typeof description === 'string') {
                    slugToDescription[urlKey] = description;
                }
            }
            Object.values(val).forEach(findNodes);
        };

        if (nextData) findNodes(nextData);

        const products = [];
        let currency = "USD";

        if (nextData) {
            let queries = nextData?.props?.pageProps?.states?.query?.value?.queries;
            if (Array.isArray(queries)) {
                for (const q of queries) {
                    const edges = q?.state?.data?.browse?.results?.edges;
                    if (Array.isArray(edges)) {
                        for (const edge of edges) {
                            const node = edge?.node;
                            if (node) {
                                const p = {
                                    aggregateRating: null,
                                    availability: "in_stock",
                                    brand: node.brand || "",
                                    category: "",
                                    currency: "USD",
                                    description: slugToDescription[node.urlKey] || "",
                                    features: [],
                                    images: [],
                                    name: node.title || "",
                                    preDiscountPrice: null,
                                    price: node.market?.state?.lowestAsk?.amount || 0,
                                    productId: node.id || "",
                                    reviews: [],
                                    seller: null,
                                    serialNumbers: [],
                                    specifications: [],
                                    url: makeAbsoluteURL(node.urlKey || ""),
                                    videos: [],
                                    isSponsored: !!node.isSponsored,
                                    badges: []
                                };
                                if (p.isSponsored) {
                                    p.badges.push({ label: "Sponsored", type: "sponsored" });
                                }

                                let variants = null;
                                let sizeDisplay = "";
                                if (p.url.includes("size=")) {
                                    const parts = p.url.split("size=");
                                    if (parts.length > 1) sizeDisplay = parts[1].split("&")[0];
                                }
                                if (sizeDisplay) {
                                    variants = {
                                        visibleOptions: [{ type: "size", value: sizeDisplay }]
                                    };
                                }
                                p.variants = variants;
                                products.push(p);
                            }
                        }
                    }
                }
            }
        }

        if (products.length === 0) {
            $("[data-testid='ProductTile'], [data-testid='VariantTile']").each((i, el) => {
                const s = $(el);
                const p = {
                    aggregateRating: null,
                    availability: "in_stock",
                    category: "",
                    features: [],
                    preDiscountPrice: null,
                    reviews: [],
                    seller: null,
                    serialNumbers: [],
                    specifications: [],
                    videos: []
                };

                let name = s.find("[data-testid='product-tile-title']").text();
                if (!name) name = s.find("p.chakra-text").first().text();
                p.name = name;

                let brand = "";
                const lowerName = name.toLowerCase();
                const multiWordBrands = ["new balance", "under armour", "fear of god", "asics tiger", "air jordan"];
                let foundMulti = false;
                for (const b of multiWordBrands) {
                    if (lowerName.startsWith(b)) {
                        brand = name.substring(0, b.length);
                        foundMulti = true;
                        break;
                    }
                }
                if (!foundMulti) {
                    brand = name.split(" ")[0] || "";
                }
                p.brand = brand;

                const priceText = s.find("[data-testid='product-tile-lowest-ask-amount']").text();
                p.currency = detectCurrency(priceText);
                p.price = extractNumericPrice(priceText);

                const href = s.find("a").attr("href") || "";
                p.url = makeAbsoluteURL(href);

                let slug = "";
                if (href) {
                    const pathOnly = href.split("?")[0];
                    const parts = pathOnly.replace(/^\/|\/$/g, "").split("/");
                    slug = parts[parts.length - 1];
                }
                p.description = slugToDescription[slug] || "";
                p.productId = slugToId[slug] || "";

                const imgTag = s.find("img");
                p.images = imgTag.attr("src") ? [{ url: imgTag.attr("src"), altText: imgTag.attr("alt") || "" }] : [];

                const sponsoredAttr = s.find("[data-testid='productTile']").attr("data-sponsored-listing");
                p.isSponsored = sponsoredAttr === "true" || s.find("[data-testid='sponsored-tag']").length > 0;
                
                p.badges = [];
                if (p.isSponsored) p.badges.push({ label: "Sponsored", type: "sponsored" });
                if (s.text().includes("Xpress Ship")) p.badges.push({ label: "Xpress Ship", type: "new" });

                let sizeText = s.find("[data-testid='product-tile-size-display']").text();
                if (!sizeText && href.includes("size=")) {
                    const parts = href.split("size=");
                    if (parts.length > 1) sizeText = decodeURIComponent(parts[1].split("&")[0]);
                }
                p.variants = sizeText ? { visibleOptions: [{ type: "size", value: sizeText.trim() }] } : null;

                products.push(p);
            });
        }

        const breadcrumbs = [];
        $("li.chakra-breadcrumb__list-item").each((i, el) => {
            const s = $(el);
            const name = s.find("a, span").text().trim().replace(/\/$/, "");
            const href = s.find("a").attr("href");
            if (name) {
                breadcrumbs.push({ name, url: makeAbsoluteURL(href || "") });
            }
        });

        const pagination = {
            currentPage: 1,
            hasNextPage: false,
            hasPreviousPage: false,
            nextPageUrl: "",
            totalPages: 1
        };

        const nav = $("[data-testid='pagination-wrapper']");
        if (nav.length > 0) {
            const nextHref = nav.find("a[aria-label='Next']").attr("href");
            if (nextHref) {
                pagination.hasNextPage = true;
                pagination.nextPageUrl = makeAbsoluteURL(nextHref);
            }
            const lastPageText = nav.find("a").last().prev().text();
            const tp = parseInt(lastPageText);
            if (!isNaN(tp)) pagination.totalPages = tp;
        }

        const searchMetadata = {
            query: "",
            resultsDisplayed: products.length,
            searchType: "keyword",
            searchUrl: url,
            totalResults: 0
        };

        const h1Text = $("h1[data-testid='search-confirmation']").text();
        const totalMatch = h1Text.match(/(\d+)/);
        if (totalMatch) searchMetadata.totalResults = parseInt(totalMatch[1]);

        return {
            breadcrumbs,
            pagination,
            products,
            searchMetadata,
            url,
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Playwright with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Playwright browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let context = null;
        let page = null;
        
        try {
            // Create context with optimizations
            context = await browser.newContext({
                ignoreHTTPSErrors: true,
                viewport: { width: 1920, height: 1080 },
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
            });
            
            page = await context.newPage();
            
            // Block unnecessary resources for performance optimization
            await page.route('**/*', (route) => {
                const resourceType = route.request().resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    route.abort();
                } else {
                    route.continue();
                }
            });
            
            // Navigate with optimized wait strategy
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            // Wait a bit for dynamic content to load
            await page.waitForTimeout(2000);
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url);
            } else {
                console.warn('No data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            if (context) await context.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    // Launch browser with performance optimizations
    const browser = await chromium.launch({
        headless: true,
        proxy: PROXY_CONFIG,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        // Process URLs in batches to control concurrency
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://stockx.com/search?s=kids+shoes',
    ];

    console.log('Starting concurrent scraping with NodeJS Playwright-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

// Run the scraper if this file is executed directly
if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };