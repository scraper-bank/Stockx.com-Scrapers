/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
puppeteer.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'stockx_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_SERVER = 'residential-proxy.scrapeops.io';
const PROXY_PORT = '8181';
const PROXY_USERNAME = 'scrapeops';
const PROXY_PASSWORD = API_KEY;

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://stockx.com";
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            const pt = (priceText || "").toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (pt.includes(code)) return currency;
            }
            return "USD";
        };

        const maximizeRes = (urlStr) => {
            if (!urlStr || !urlStr.includes("stockx.com/images")) return urlStr;
            let result = urlStr;
            result = result.replace(/w=\d+/, "w=1200");
            result = result.replace(/h=\d+/, "h=857");
            result = result.replace(/q=\d+/, "q=90");
            result = result.replace(/dpr=\d+/, "dpr=2");
            result = result.replace(/&updated_at=\d+/, "");
            result = result.replace(/\?updated_at=\d+&/, "?");
            result = result.replace(/\?updated_at=\d+$/, "");
            result = result.replace(/&fm=[^&]+/, "");
            result = result.replace(/&auto=[^&]+/, "");
            return result;
        };

        // Extract JSON-LD and NextData
        let productLD = null;
        $('script[type="application/ld+json"]').each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                if (data["@type"] === "Product") productLD = data;
            } catch (e) {}
        });

        let nextData = null;
        try {
            const nextText = $('script#__NEXT_DATA__').text();
            if (nextText) nextData = JSON.parse(nextText);
        } catch (e) {}

        const outputData = {};
        outputData["aggregateRating"] = null;

        // Availability
        let avail = "in_stock";
        if (productLD?.offers?.availability?.includes("OutOfStock")) {
            avail = "out_of_stock";
        }
        outputData["availability"] = avail;

        // Brand
        let brand = productLD?.brand?.name || "";
        if (!brand) brand = $("li.chakra-breadcrumb__list-item").last().text().trim();
        if (!brand) brand = $("[data-component='product-trait']:contains('Brand') p").text().trim();
        outputData["brand"] = brand;

        // Category
        let category = productLD?.category || "";
        if (!category) {
            $('script[type="application/ld+json"]').each((i, el) => {
                try {
                    const bData = JSON.parse($(el).text());
                    if (bData["@type"] === "BreadcrumbList") {
                        const items = bData.itemListElement;
                        if (items && items.length > 1) {
                            category = items[1].item?.name?.toLowerCase() || "";
                        }
                    }
                } catch (e) {}
            });
        }
        outputData["category"] = category;

        // Currency
        let currency = productLD?.offers?.priceCurrency || "";
        if (!currency) {
            const priceT = $("[data-testid='trade-box-buy-amount']").text();
            currency = detectCurrency(priceT);
        }
        outputData["currency"] = currency;

        // Description
        let description = productLD?.description || $("[data-testid='product-description'] p").text().trim();
        outputData["description"] = description;

        outputData["features"] = [];

        // Image Extraction
        const resultImages = [];
        const seenURLs = new Set();
        let productTitle = $("h1[data-component='primary-product-title']").text().trim() || productLD?.name || "";

        // Strategy 1: NEXT_DATA
        if (nextData) {
            try {
                const queries = nextData.props?.pageProps?.states?.query?.value?.queries || [];
                for (const q of queries) {
                    const product = q.state?.data?.product;
                    if (product) {
                        if (!productTitle) productTitle = product.title;
                        const gallery = product.media?.gallery || [];
                        gallery.forEach((imgURL, idx) => {
                            if (imgURL) {
                                const highResURL = maximizeRes(imgURL);
                                if (!seenURLs.has(highResURL)) {
                                    let alt = productTitle;
                                    if (idx === 1 || highResURL.includes("-2.jpg")) {
                                        alt = productTitle + " back view";
                                    } else if (idx > 1) {
                                        alt = `${productTitle} view ${idx + 1}`;
                                    }
                                    resultImages.push({ url: highResURL, alt_text: alt });
                                    seenURLs.add(highResURL);
                                }
                            }
                        });
                    }
                }
            } catch (e) {}
        }

        // Strategy 2: LD+JSON Fallback
        if (resultImages.length === 0 && productLD?.image) {
            const highResURL = maximizeRes(productLD.image);
            if (!seenURLs.has(highResURL)) {
                resultImages.push({ url: highResURL, alt_text: productLD.name || productTitle });
                seenURLs.add(highResURL);
            }
        }

        // Strategy 3: DOM Fallback
        if (resultImages.length < 2) {
            $("[data-component='MultiImage'] img, [data-testid='MultiImage'] img").each((i, el) => {
                let src = $(el).attr("src") || $(el).attr("srcset");
                if (src) {
                    src = src.split(/\s+/)[0];
                    const highResURL = maximizeRes(src);
                    if (!seenURLs.has(highResURL)) {
                        let alt = productTitle;
                        if (highResURL.includes("-2.jpg")) {
                            alt = productTitle + " back view";
                        } else if (resultImages.length > 0) {
                            alt = `${productTitle} view ${resultImages.length + 1}`;
                        }
                        resultImages.push({ url: highResURL, alt_text: alt });
                        seenURLs.add(highResURL);
                    }
                }
            });
        }
        outputData["images"] = resultImages;

        // Name
        outputData["name"] = productTitle || $("[data-component='primary-product-title']").text().trim();

        outputData["preDiscountPrice"] = null;

        // Price
        let price = productLD?.offers?.lowPrice || 0;
        if (!price) {
            const priceText = $("[data-testid='trade-box-buy-amount']").text().replace(/,/g, "");
            const match = priceText.match(/[\d,]+(?:\.\d+)?/);
            if (match) price = parseFloat(match[0]);
        }
        outputData["price"] = price;

        outputData["productId"] = productLD?.sku || "";
        outputData["reviews"] = [];

        // Seller
        const seller = {
            name: "StockX Verified Seller",
            rating: null,
            url: "https://stockx.com/about/verification/",
        };
        $("a.chakra-link").each((i, el) => {
            const linkText = $(el).text();
            if (linkText.includes("Verified Seller")) {
                const href = $(el).attr("href");
                seller.url = makeAbsoluteURL(href);
                if (!href.includes("/verification")) {
                    seller.name = linkText.replace(/Learn More|Opens in new tab/g, "").trim();
                }
            }
        });
        outputData["seller"] = seller;

        // Serial Numbers
        const serialNumbers = [];
        if (productLD?.sku) serialNumbers.push({ type: "SKU", value: productLD.sku });
        if (productLD?.gtin) serialNumbers.push({ type: "GTIN", value: productLD.gtin });
        
        $("[data-component='product-trait']").each((i, el) => {
            const key = $(el).find("span").text().trim();
            const val = $(el).find("p").text().trim();
            if (key === "Style") serialNumbers.push({ type: "Other", value: val });
        });
        outputData["serialNumbers"] = serialNumbers;

        // Specs
        const specs = [];
        $("[data-component='product-trait']").each((i, el) => {
            const key = $(el).find("span").text().trim();
            const val = $(el).find("p").text().trim();
            if (key && val) specs.push({ key, value: val });
        });
        outputData["specifications"] = specs;

        // URL
        let finalUrl = productLD?.url || $('meta[property="og:url"]').attr("content") || url;
        outputData["url"] = makeAbsoluteURL(finalUrl);
        outputData["videos"] = null;
        outputData["timestamp"] = new Date().toISOString();

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Puppeteer with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Puppeteer browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let page = null;
        
        try {
            page = await browser.newPage();
            
            await page.setViewport({ width: 1920, height: 1080 });
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36');
            
            await page.setRequestInterception(true);
            page.on('request', (request) => {
                const resourceType = request.resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    request.abort();
                } else {
                    request.continue();
                }
            });
            
            await page.authenticate({
                username: PROXY_USERNAME,
                password: PROXY_PASSWORD
            });
            
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            // Allow dynamic content/NEXT_DATA to hydrate
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url);
            } else {
                console.warn('No data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    const browser = await puppeteer.launch({
        headless: 'new',
        ignoreHTTPSErrors: true,
        args: [
            `--proxy-server=http://${PROXY_SERVER}:${PROXY_PORT}`,
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://stockx.com/adidas-ctt-chinese-track-top-31-gender-neutral-jacket-asia-sizing-dark-grey',
    ];

    console.log('Starting concurrent scraping with NodeJS Puppeteer-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };